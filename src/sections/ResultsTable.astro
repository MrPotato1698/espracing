---
import { turso } from "../turso";

interface Race {
  ChampID: string;
  ChampName: string;
  RaceName: string;
  filename: string;
}

interface Championship {
  name: string;
  races: Race[];
}

const resultSet = await turso.execute(
  "SELECT DISTINCT R.name AS RaceName, R.filename, C.name AS ChampName, C.id AS ChampID FROM Championship AS C INNER JOIN Race AS R ON C.id = R.championship"
);
const RacesData: Race[] = resultSet.rows as unknown as Race[];

let racesByChampionship: { [key: string]: Championship } = {};

if (RacesData.length == 0) {
  console.log("No hay datos");
} else {
  // Agrupamos las carreras por campeonato
  racesByChampionship = RacesData.reduce(
    (acc: { [key: string]: Championship }, race: Race) => {
      if (!acc[String(race.ChampID)]) {
        acc[String(race.ChampID)] = {
          name: String(race.ChampName) ?? "Unknown Championship",
          races: [],
        };
      }
      acc[String(race.ChampID)].races.push(race);
      return acc;
    },
    {} as { [key: string]: Championship }
  );
}
---

<p class="py-4 text-2xl font-bold text-center">
  Selecciona la carrera a revisar
</p>
<select
  id="select-champs"
  class="block m-auto w-4/5 px-4 py-3 text-lg font-medium rounded-xl pe-9 focus:border-[#da392b] disabled:opacity-50 disabled:pointer-events-none bg-[#19191c] border-neutral-700 text-[#f9f9f9] placeholder-neutral-500"
>
  {
    Object.entries(racesByChampionship).map(([champId, champData]) => (
      <optgroup label={champData.name} class="font-semibold py-2">
        {champData.races.map((race) => (
          <option
            value={race.filename?.toString()}
            class="text-[#f7f7f7]"
            data-champ={champData.name}
          >
            {race.RaceName}
          </option>
        ))}
      </optgroup>
    ))
  }
</select>

<!-- Tabla de resultados -->
<div class="container mx-auto">
  <div class="section">
    <button
      id="loadButton"
      class="no-underline bg-[#19191c] rounded-xl my-4 font-medium text-white text-lg py-4 px-8 block mx-auto hover:text-[#0f0f0f] hover:bg-[#da392b]"
    >
      Cargar Datos
    </button>

    <div id="resultado2"></div>
    <table class="w-full border-collapse border border-[#f9f9f9]">
      <thead class="font-medium bg-[#da392b]">
        <tr class="tabletitle">
          <th>Pos</th>
          <th>Nombre</th>
          <th>Equipo</th>
          <th>Clase</th>
          <th colspan="2">Coche</th>
          <th colspan="2">Gain/Lost</th>
          <th>Tiempo Total</th>
          <th>Nº Vueltas</th>
          <th>Vuelta Rápida</th>
          <th>Media Vueltas</th>
          <th>Golpes</th>
          <th>Lastres</th>
        </tr>
      </thead>
      <tbody id="resultado" class="font-normal"> </tbody>
    </table>
  </div>
</div>

<script>
  import "@/pages/api/raceresults/results.ts";
</script>

<script>
  const select = document.getElementById("select-champs") as HTMLSelectElement;

  function updateSelectText() {
    const selectedOption = select.options[select.selectedIndex];
    if (selectedOption) {
      const champName = selectedOption.dataset.champ;
      const raceName =
        selectedOption.dataset.originalText || selectedOption.textContent;

      // Restaurar todos los textos originales
      Array.from(select.options).forEach((opt) => {
        opt.textContent = opt.dataset.originalText || opt.textContent;
      });

      // Actualizar solo la opción seleccionada
      if (raceName && !raceName.includes(champName ?? "")) {
        selectedOption.textContent = `${champName} - ${raceName}`;
      }
    }
  }

  // Guardar los textos originales
  Array.from(select.options).forEach((opt) => {
    opt.dataset.originalText = opt.textContent ?? "";
  });

  select.addEventListener("change", updateSelectText);
  select.addEventListener("focus", () => {
    Array.from(select.options).forEach((opt) => {
      opt.textContent = opt.dataset.originalText || opt.textContent;
    });
  });
  select.addEventListener("blur", updateSelectText);

  // Inicializar el texto del select
  updateSelectText();

  // Observar cambios en el valor del select (para manejar cambios programáticos)
  const observer = new MutationObserver((mutations) => {
    mutations.forEach((mutation) => {
      if (
        mutation.type === "attributes" &&
        mutation.attributeName === "value"
      ) {
        updateSelectText();
      }
    });
  });

  observer.observe(select, { attributes: true });
</script>

<style>
  .container {
    width: 99%;
  }

  &::-ms-expand {
    display: none;
  }

  /* Remove focus outline */
  &:focus {
    outline: none;
  }
  td {
    text-align: center;
  }

  tbody tr td:nth-child(1) {
    font-family: "500";
  }

  tbody tr:nth-child(odd) {
    background-color: "#0f0f0f";
  }

  tbody tr:nth-child(even) {
    background-color: "#19191c";
  }
</style>
